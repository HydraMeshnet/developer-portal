// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility that Flutter provides. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter_test/flutter_test.dart';
///###FLUTTER_STEP_1
import 'dart:convert';
import 'dart:typed_data';

// Import the necessary modules from our SDK
import 'package:iop_sdk/crypto.dart';
import 'package:iop_sdk/layer1.dart';
import 'package:iop_sdk/layer2.dart';
import 'package:iop_sdk/network.dart';
///###FLUTTER_STEP_1

void main() {
  test('SSI Contract - Proof of Existence', () async {
///###FLUTTER_STEP_2
// Configure the network and account settings
final network = Network.TestNet;
final unlockPassword = 'correct horse battery staple';
final accountNumber = 0;

// Initialize the transaction sender's vault to send layer-1 transactions 
final gasVault = Vault.create(Bip39.DEMO_PHRASE, '', unlockPassword);
HydraPlugin.init(gasVault, unlockPassword, network, accountNumber);

// Get the address and the private interface from the vault's hydra plugin
final hydraPlugin = HydraPlugin.get(gasVault, network, accountNumber);
final senderAddress = hydraPlugin.public.key(accountNumber).address;
final senderPrivate = hydraPlugin.private(unlockPassword);
///###FLUTTER_STEP_2

///###FLUTTER_STEP_3
// YOU HAVE TO SAVE THE PASSPHRASE SECURELY!
final phrase = Bip39('en').generatePhrase();

// Creates a personal vault based on the BIP39 passphrase, password and unlock password
final vault = Vault.create(
  phrase,
  '8qjaX^UNAafDL@!#', // The 25th word of the passphrase
  unlockPassword,     // Encrypts the master seed
);
///###FLUTTER_STEP_3

///###FLUTTER_STEP_4
// Initialize the Morpheus plugin (Layer-2 SSI) on your personal vault:
MorpheusPlugin.init(vault, unlockPassword);
final morpheusPlugin = MorpheusPlugin.get(vault);

// Selects the first DID
final did = morpheusPlugin.public.personas.did(0);
print('Using DID: ${did.toString()}');
///###FLUTTER_STEP_4

if(did == null) {
  throw Exception('DID is null');
}

///###FLUTTER_STEP_5
// Acquire the default key
final keyId = did.defaultKeyId();

// The contract details
final contractStr = 'A long legal document, e.g. a contract with all details';
final contractBytes = Uint8List.fromList(utf8.encode(contractStr)).buffer.asByteData();

// Acquire the plugin's private interface that provides you the signing interface
final morpheusPrivate = morpheusPlugin.private(unlockPassword);

// The signed contract, which you need to store securely!
final signedContract = morpheusPrivate.signDidOperations(keyId, contractBytes);
final signedContractJson = <String, dynamic>{
  'content': utf8.decode(signedContract.content.content.buffer.asUint8List()), // you must use this Buffer wrapper at the moment, we will improve in later releases,
  'publicKey': signedContract.signature.publicKey.value,
  'signature': signedContract.signature.bytes.value,
};
print('Signed contract: ${stringifyJson(signedContractJson)}');
///###FLUTTER_STEP_5

///###FLUTTER_STEP_6
// The beforeProof (a.k.a. Proof of Existence) is generated by hashing the signed contract
final beforeProof = digestJson(signedContractJson);
print('Proof of Existence: ${beforeProof.value}');
///###FLUTTER_STEP_6

if(beforeProof == null) {
    throw Exception('beforeProof is null');
}

///###FLUTTER_STEP_7
// Create the layer-2 data structure
final morpheusAssetBuilder = new MorpheusAssetBuilder.create();
morpheusAssetBuilder.addRegisterBeforeProof(beforeProof);
final morpheusAsset = morpheusAssetBuilder.build();

// Initialize the layer-1 API
final networkConfig = NetworkConfig.fromNetwork(network);
final layer1Api = Layer1Api.createApi(networkConfig);

// Query and increment the current nonce of the transaction sender
int nonce = await layer1Api.getWalletNonce(senderAddress);
nonce = nonce + 1;

// Now you are ready to send the transaction on layer-1
final txId = await layer1Api.sendMorpheusTx(senderAddress, morpheusAsset, senderPrivate, nonce: nonce);
print('Transaction ID: $txId');
///###FLUTTER_STEP_7

///###FLUTTER_STEP_8
// Block confirmation time
await Future.delayed(Duration(seconds: 12));

// Layer-1 transaction must be confirmed
final txStatus = await layer1Api.getTxnStatus(txId);
print('Tx status: ${txStatus.toJson()}');

// Initialize the layer-2 API to query the transaction status
final layer2Api = Layer2Api.createMorpheusApi(networkConfig);
final ssiTxStatus = await layer2Api.getTxnStatus(txId);
print('SSI Tx confirmed: $ssiTxStatus');
///###FLUTTER_STEP_8

///###FLUTTER_STEP_9
// We assume that signedContract is in scope and available
final expectedContentId = digestJson(signedContractJson);
///###FLUTTER_STEP_9

///###FLUTTER_STEP_10
// Query the blockchain for the hash of the signed contract (Proof of Existence)
final history = await layer2Api.getBeforeProofHistory(expectedContentId);
print('Proof history: ${history.toJson()}');
///###FLUTTER_STEP_10

if(history.contentId != expectedContentId) {
  throw Exception('Content Id does not match');
}
  });
}
